#define THRESHOLD      330
#define DEBOUNCE_TIME  220
#define COLUMN         16
#define ROW            16

#define NORTH           1
#define WEST            2
#define NORTH_WEST      3

boolean toggel[ROW][COLUMN] = false;
short int labels[ROW][COLUMN] = 0;
short int linked[ROW][COLUMN] = 0;
short int curentLabel = 1;


//////////////////// algorithm TwoPass(data)

void ConnectedComponents(){

  //////////////////// First pass
  for( int row=0; row<ROW; row++ ){
    for( int column=0; column<COLUMN; column++ ){
      // if curentValue is true
      if( toggel[row][column] == true ){ // toggel is true : KEY IN FREE
        // if left pixel is connected with the current pixel
        if( collumn > 0 && toggel[row][column-1] == true ){
          labels[row][column] = labels[row][column-1]; // temporary label
          linked[row][column] = WEST;                  // equivalence classe
        }
        // if top pixel is connected with the current pixel
        if( row > 0 && toggel[row-1][column] == true ){
          labels[row][column] = labels[row-1][column];  // take temporary neighbors label
          linked[row][column] = NORTH;                  // equivalence classe
        }
        // if left and top pixels are not connected with the current pixel
        if( row > 0 && collumn > 0 ){
          if( toggel[row][column-1] == false && toggel[row-1][column] == false ){
            labels[row][column] = curentLabel++; // create a new label
          }
        }

        // Find the smallest label
        
        L = neighbors labels
          labels[row][column] = min(L);
        for label in L
          linked[label] = union(linked[label], L)
        }
        if( toggel[row][column] == false ){
        }
    }
  }
  
  ////////////////////  Second pass
  for( int row=0; row<ROW; row++ ){
    for( int column=0; column<COLUMN; column++ ){
      if( data[row][column] == false ){
        labels[row][column] = find( labels[row][column] );      
        }
      }
    }
  }
