// Matrix shield V1.1 + Xbee//

#include <XBee.h>

XBee xbee = XBee();

const int outLatchPin = 10;      //  pin connected to latch pin (ST_CP) of HC595 8-BIT shift register
const int outClockPin = A0;      //  pin connected to clock pin (SH_CP) of HC595
const int outDataPin = 13;       //  pin connected to Data in (DS) of 74HC595

// Multiplexer 74HC4067 control pins
// four bits to adress sixten input pins
const int muxControlPin[] = {
  A4, // Analog Pin A4
  A3, // Analog Pin A3
  A1, // Analog Pin A1
  A2  // Analog Pin A2
};

const int SENS_PIN = A5;               // multiplexer output "SIG" pin pin is connected to Arduino Analog5 pin
const int ARRAY_SIZE = 256;           // how many sensor/bytes in the sensor matrix
const int TRANSMIT_PACKET_SIZE = 64;  // how many packets to send all sensor matrix datas (256 / 4 = 64)

int analogValue = 0;         // variable use to store analog inputs values

byte readSensorMatrix[ARRAY_SIZE] = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

// Maximum payload size : http://www.digi.com/support/kbase/kbaseresultdetl?id=3345
byte payload[TRANSMIT_PACKET_SIZE] = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

// 16-bit addressing: Enter address of remote XBee, typically the coordinator
Tx16Request tx = Tx16Request(0x1874, payload, sizeof(payload));

////////////////////////////////////// SETUP
void setup(){
  // set up serial Xbee communication to 19200 bauds
  xbee.begin(57600);

  // set shift-registers pins as output
  pinMode(outLatchPin, OUTPUT);
  pinMode(outClockPin, OUTPUT);
  pinMode(outDataPin, OUTPUT);

  // set analog-multiplexeur control pins as output
  pinMode(muxControlPin[0], OUTPUT);
  pinMode(muxControlPin[1], OUTPUT);
  pinMode(muxControlPin[2], OUTPUT);
  pinMode(muxControlPin[3], OUTPUT);

  // set analog-multiplexeur pins to LOW
  digitalWrite(muxControlPin[0], LOW);
  digitalWrite(muxControlPin[1], LOW);
  digitalWrite(muxControlPin[2], LOW);
  digitalWrite(muxControlPin[3], LOW);

  // delay for the xbee module setup
  delay(7000);
}

////////////////////////////////////// Boucle principale

void loop(){

  scanMatrix(); // scan all 256 matrix sensors
  
  // set the header in payload array
  for(int i=0; i<TRANSMIT_PACKET_SIZE; i++){
    payload[i] = 255;
  }
  // send the header
  xbee.send(tx);
  delay(2);

  // send the 256 matrix sensors in four pakets of 64 bytes
  
  for(int j=0; j<4; j++){
    for(int k=0; k<TRANSMIT_PACKET_SIZE; k++){
      payload[k] = readSensorMatrix[ (j * 64) + k ];
      // payload[k] = 33;
    }
    xbee.send(tx);
    delay(2);
    }
}

////////////////////////////////////// FONCTIONS
///////////// Scan the 16x16 matrix sensors
void scanMatrix(){

  for(int row=0; row<16; row++){
    registerWrite(row, outDataPin, outClockPin, outLatchPin); // set row position
    readMux(row); // read 16 columns
  }
}

///////////// write HIGH to an output column 
void registerWrite(unsigned int whichColumn, int whichDataPin, int whichClockPin, int whichLatchPin){

  byte outputVal = 0;
  // array to set matrix pins order
  byte bitPos[16] = {
    0x100,  // 8
    0x200,  // 7
    0x400,  // 6
    0x800,  // 5
    0x1000, // 4
    0x2000, // 3
    0x4000, // 2
    0x80,   // 9
    0x1,    // 16
    0x2,    // 15
    0x4,    // 14
    0x8,    // 13
    0x10,   // 12 
    0x20,   // 11
    0x40,   // 10
    0x8000  // 1
  };

  outputVal = bitPos[whichColumn];

  // set latchPin low
  digitalWrite(whichLatchPin, LOW);
  //shift out highbyte
  shiftOut(whichDataPin, whichClockPin, LSBFIRST, outputVal);
  // shift out lowbyte
  shiftOut(whichDataPin, whichClockPin, LSBFIRST, (outputVal >> 8));
  // set latchPin high
  digitalWrite(whichLatchPin, HIGH);
}

///////////// fonction to read 16 matrix columns
int readMux(int whichRow){

  int sensingIndex = 0;
  
  int muxChannels[16][4]={
  { 1, 1, 1, 0 }, // channel 7
  { 0, 1, 1, 0 }, // channel 6
  { 1, 0, 1, 0 }, // channel 5
  { 0, 0, 1, 0 }, // channel 4
  { 1, 1, 0, 0 }, // channel 3
  { 0, 1, 0, 0 }, // channel 2
  { 1, 0, 0, 0 }, // channel 1
  { 0, 0, 0, 0 }, // channel 0
  { 1, 1, 1, 1 }, // channel 15
  { 0, 1, 1, 1 }, // channel 14
  { 1, 0, 1, 1 }, // channel 13
  { 0, 0, 1, 1 }, // channel 12
  { 1, 1, 0, 1 }, // channel 11
  { 0, 1, 0, 1 }, // channel 10
  { 1, 0, 0, 1 }, // channel 9
  { 0, 0, 0, 1 }  // channel 8
  };

  for(int column=0; column<16; column++){ // 16 columns

    // set which multiplexer analog pin to read
    for(int i=0; i<4; i++){
      digitalWrite(muxControlPin[i], muxChannels[column][i]);
    }
    // delay to slow down analog readings
    delayMicroseconds(10);
    // read an analog input
    analogValue = analogRead(SENS_PIN) / 4;
    // convert two dimensional in a simple 1D array
    sensingIndex = (whichRow * 16) + column;
    // store the 255 analog value in the payload array
    readSensorMatrix[sensingIndex] = analogValue;
  }

}
